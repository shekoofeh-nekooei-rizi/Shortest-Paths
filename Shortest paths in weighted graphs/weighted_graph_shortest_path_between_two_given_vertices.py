# -*- coding: utf-8 -*-
"""weighted_graph_shortest_path_between_two_given_vertices.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oABu5B6G7IvOKYlsubWEiwna-2BJF3e_

### **Author: Shekoofeh Nekooei Rizi**

This program computes the shortest distance and the corresponding path **between two given vertices** in a weighted, undirected graph.


I implemented the **Dijkstra algorithm** for this purpose.


My implementation is pretty efficient in terms of both running time and memory usage.


I utilized Python's built-in priority queue (heapq) to ensure fast execution, assuming the input graph is not [overly] sparse.

Note that in this program vertices are represented by positive consecutive integers starting from 1.
"""

import heapq

def dijkstra_two_vertices(n, edges, start_vertex, terminal_vertex):
    """
    Implementation of Dijkstra's algorithm for finding the shortest path between two vertices in an undirected, weighted graph.

    n: the number of vertices in the graph. Vertices are represented by integer numbers from 1 to n, inclusive

    edges: a list of edges, where each edge is represented as a list [u, v, w], where u and v are the vertices and w is the weight of the edge.

    start_vertex: the starting vertex from which the shortest path is to be found.
    terminal_vertex: the terminal vertex to which the shortest path is to be found.

    Return:
    A tuple in the form of (distance, path)
    When there is no path between start_vertex and terminal_vertex, the program returns (inf, None)
    """
    graph = {v:[] for v in range(1,n+1)}
    for u, v, w in edges:
        graph[u].append((v, w))
        graph[v].append((u, w))
    infinity = float('inf')
    dist = [infinity] * (n+1)
    dist[start_vertex] = 0
    parent = [None] * (n+1)
    H = []
    heapq.heappush(H, (dist[start_vertex], start_vertex))
    visited = set()
    while H:
        d, current_node = heapq.heappop(H)

        if current_node in visited:
            continue

        visited.add(current_node)

        if current_node == terminal_vertex:
            break

        for neighbor, w in graph[current_node]:
            if dist[neighbor] > d + w:
                dist[neighbor] = d + w
                heapq.heappush(H, (dist[neighbor], neighbor))
                parent[neighbor] = current_node

    if terminal_vertex not in visited:
        return infinity, None
    path = []
    v = terminal_vertex

    while v is not None:
        path.append(v)
        v = parent[v]
    path.reverse()

    return dist[terminal_vertex], path

"""## **Small Sample Tests**"""

n = 4
edges = [[1, 2, 10], [2, 3, 10], [3, 4, 10], [1, 4, 50]]
start_vertex = 4
terminal_vertex = 1
dijkstra_two_vertices(n, edges, start_vertex, terminal_vertex)

n = 5
edges = [[1, 2, 70], [1, 3, 50], [2, 3, 20], [4, 5, 10] ]
dijkstra_two_vertices(n, edges, 1, 5)

"""## **Big Sample Test**

For this sample we read problem's data from an input file.

This input provides the adjacenly lists for vertices of an undirected/weighted graph.

Each row in the file consists of the node tuples that are adjacent to that particular vertex along with the weight [or length] of that edge.

For instance row 5 starts as:
5    200, 4009    112,1522
which shows an edge between 5 and 200 with length 4009, and an edge between 5 and 112 with length 1522

This input sample has 200 vertices and 1867 undirected, weighted edges.
"""

def read_input_file(filename):
    n = 0
    edges = []
    with open(filename, 'r') as file:
        for line in file:
            n += 1
            segments = line.strip().split()
            u = int(segments[0])
            for pair in segments[1:]:
                v, w = map(int, pair.split(','))
                edges.append([u,v,w])
    return n, edges

n, edges = read_input_file('sample_input.txt')

dijkstra_two_vertices(n, edges, 5, 200)

dijkstra_two_vertices(n, edges, 33, 7)

dijkstra_two_vertices(n, edges, 37, 148)

dijkstra_two_vertices(n, edges, 100, 71)

import random

start_vertex = random.randint(1, n)
terminal_vertex = random.randint(1, n)

print("start_vertex, randomly picked, is " + str(start_vertex) + "\n")
print("terminal_vertex, randomly picked, is " + str(terminal_vertex) + "\n")

dijkstra_two_vertices(n, edges, start_vertex, terminal_vertex)