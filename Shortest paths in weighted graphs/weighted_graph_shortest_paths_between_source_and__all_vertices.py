# -*- coding: utf-8 -*-
"""weighted_graph_shortest_paths_between_source_and _all_vertices.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Z0Wi7ja09p9XgPdv490nExtZzz0gLxyq

### **Author: Shekoofeh Nekooei Rizi**

This program computes the shortest distances and the corresponding shortest paths between a given vertex as a **source and all vertices** in a weighted, undirected graph.


I implemented the **Dijkstra algorithm** for this purpose.


My implementation is pretty efficient in terms of both running time and memory usage.


I utilized Python's built-in priority queue (heapq) to ensure fast execution, assuming the input graph is not [overly] sparse.

Note that in this program, vertices are represented by positive consecutive integers starting from 1.
"""

import heapq

def dijkstra_source_to_all(n, edges, source_vertex):
    """
    Computes the shortest distances and corresponding paths from a source_vertex
    to all other vertices in an undirected weighted graph using Dijkstra's algorithm.

    n: the number of vertices in the graph. Vertices are represented by integer numbers from 1 to n, inclusive

    edges: a list of edges, where each edge is represented as a list [u, v, w], where u and v are endpoint vertices and w is the weight of the edge.

    source_vertex: the starting vertex from which the shortest paths are to be found.

    return:
    List of tuples.
    Each element in the final result is a tuple in the form of (distance, [path])
    the first vertex in [path] is the source vertex and the last vertex is the destination vertex.
    distance is sum of edges' weights in this path.
    """

    graph = {v:[] for v in range(1,n+1)}
    for u, v, w in edges:
        graph[u].append((v, w))
        graph[v].append((u, w))
    infinity = float('inf')
    dist = [infinity] * (n+1)
    dist[source_vertex] = 0
    parent = [None] * (n+1)
    H = []
    heapq.heappush(H, (dist[source_vertex], source_vertex))
    visited = set()
    paths = {}
    paths[source_vertex] = [source_vertex]
    while H:
        d, current_node = heapq.heappop(H)

        if current_node in visited:
            continue

        visited.add(current_node)

        for neighbor, w in graph[current_node]:
            if dist[neighbor] > d + w:
                dist[neighbor] = d + w
                heapq.heappush(H, (dist[neighbor], neighbor))
                paths[neighbor] = paths[current_node] + [neighbor]

    for v in range(1, n+1):
        if v not in visited:
            paths[v] = None

    result = [(dist[i], paths.get(i)) for i in range(1, len(dist))]

    return result

"""## **Small Sample Tests**"""

n = 4
edges = [[1, 2, 10], [2, 3, 10], [3, 4, 10], [1, 4, 50]]
dijkstra_source_to_all(n, edges, 2)

n = 6
edges = [[1, 2, 10], [1, 3, 100], [2, 3, 1000], [3, 5, 10], [5, 6, 10000] ]
dijkstra_source_to_all(n, edges, 1)

n = 10
edges = [[1, 2, 10], [2, 3, 10], [3, 4, 10], [4, 5, 10], [5, 6, 10], [6, 7, 10], [7, 8, 10], [8, 9, 10], [9, 10, 10]]
dijkstra_source_to_all(n, edges, 6)

"""## **Big Sample Test**

For this sample we read problem's data from an input file.

This input provides the adjacenly lists for vertices of an undirected/weighted graph.

This input sample has 200 vertices and 1867 edges.
"""

def read_input_file(filename):
    n = 0
    edges = []
    with open(filename, 'r') as file:
        for line in file:
            n += 1
            segments = line.strip().split()
            u = int(segments[0])
            for pair in segments[1:]:
                v, w = map(int, pair.split(','))
                edges.append([u,v,w])
    return n, edges

n, edges = read_input_file('sample_input.txt')

dijkstra_source_to_all(n, edges, 11)

dijkstra_source_to_all(n, edges, source_vertex = 5)

import random

source_vertex = random.randint(1, n)

print("source_vertex, randomly picked, is " + str(source_vertex) + "\n")

dijkstra_source_to_all(n, edges, source_vertex)