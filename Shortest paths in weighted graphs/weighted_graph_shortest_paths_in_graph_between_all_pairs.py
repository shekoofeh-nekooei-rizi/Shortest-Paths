# -*- coding: utf-8 -*-
"""weighted_graph_shortest_paths_in_graph_between_all_pairs.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WSSD96p8Jv1ymjiVRDtnXMw9RT9HqC4P
"""

def floyd_warshall(n, edges):
    """
    This function computes the shortest distances and paths between all pairs of vertices in a graph using the Floyd-Warshall algorithm.

    "n" is the number of vertices in the graph. Note that vertices are consecutive vertices from 1 to n.

    "edges" is a list of weighted edges in the form of [u, v, w] where u and v are the end points of the edge and w is the weight of that edge.

    This function returns two lists (matrix in other words): distance matrix and paths matrix.

    Elements in the distance matrix show the shortest distance between the corresponding nodes in the graph. So, for example, the element in the first row and second column shows the shortest path between vertex 1 and 2

    Analogously, the elements in the paths matrix show the vertices in the corresponding shortest path.

    """

    infinity = float('inf')
    dist = [[infinity] * (n+1) for _ in range(n+1)]
    next_node_in_path = [[None] * (n+1) for _ in range(n+1)]

    for u, v, w in edges:
        dist[u][v] = w
        dist[v][u] = w
        next_node_in_path[u][v] = v
        next_node_in_path[v][u] = u

    for i in range(1, n+1):
        dist[i][i] = 0
        next_node_in_path[i][i] = i

    for i in range(1, n+1):
        for j in range(1, n+1):
            for k in range(1, n+1):
                if dist[j][k] > dist[j][i] + dist[i][k]:
                    dist[j][k] = dist[j][i] + dist[i][k]
                    next_node_in_path[j][k] = next_node_in_path[j][i]

    paths = [[None] * (n+1) for _ in range(n+1)]
    for i in range(1, n+1):
        for j in range(1, n+1):
            if i != j and next_node_in_path[i][j] is not None:
                paths[i][j] = reconstruct_path(next_node_in_path, i, j)


    return [row[1:] for row in dist[1:]], [row[1:] for row in paths[1:]]

def reconstruct_path(next_node_in_path, i, j):
    if next_node_in_path[i][j] is None:
        return None
    path = [i]
    while i != j:
        i = next_node_in_path[i][j]
        path.append(i)
    return path

"""## **Sample Tests**"""

n = 5
edges = [[1, 2, 10], [1, 3, 100], [1, 4, 110], [2, 3, 50], [3, 4, 200], [1, 5, 20]]

floyd_warshall(n, edges)

n = 4
edges = [[1, 2, 10], [1, 3, 200], [1, 4, 3000]]
floyd_warshall(n, edges)

def read_input_file(filename):
    n = 0
    edges = []
    with open(filename, 'r') as file:
        for line in file:
            n += 1
            segments = line.strip().split()
            u = int(segments[0])
            for pair in segments[1:]:
                v, w = map(int, pair.split(','))
                edges.append([u,v,w])
    return n, edges

def write_output_file(result, output_file_name):
    with open(output_file_name, 'w') as file:
        for d in result[0]:
            file.write(str(d) + "\n")
        for d in result[1]:
            if d is not None:
                file.write(str(d) + "\n")

n, edges = read_input_file('sample_input.txt')

# result = floyd_warshall(n, edges)
distances, paths = floyd_warshall(n, edges)
write_output_file((distances, paths), 'sample_output_floyd_warshall_distances_and_paths.txt')

