# -*- coding: utf-8 -*-
"""shortest_paths_from_source_to_other_vertices.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14Es9yQy3KTa_1gJZklvaL2ASDKcz1zN-

**Author: Shekoofeh Nekooei Rizi**

This program computes the shortest paths and corresponding lengths between a given source vertex to all vertices in an unweighted/undirected given graph.

I implement Breadth First Search for this purpose.

For illustration, I include some toy examples, as well as an example using a big dataset that can be found here:

http://snap.stanford.edu/data/github-social.html
"""

from collections import deque

def shortest_paths_from_source(n, edges, source):

    """
    This function computes the shortest paths from a given "source" vertex to all vertices in a given unweighted/undirected graph which is defined by its vertex range and list of edges.

    The vertices of the given graph are consecutive integer numbers from 0 to "n" [inclusive].
    The "edges" is a list of undirected edges in the form of [u, v] showing an edge between two vertices u and v.

    It outputs a list of tuples containing the distances and paths in the form of:

    (shortest_distance, [path])

    which is corresponding to the shortest path from source to destination vertex.
    The first element in [path] is the given source and the last one is the destinaion vertex.

    When there is no path between source and destination_vertex, shortest_distanceÂ is 'inf' and the path is 'None'
    """

    graph = {v:[] for v in range(n+1)}
    for e in edges:
        graph[e[0]].append(e[1])
        graph[e[1]].append(e[0])

    infinity = float('inf')
    dist = [infinity] * (n+1)
    dist[source] = 0

    visited = set()
    visited.add(source)

    Q = deque()
    Q.append(source)

    paths = {}
    paths[source] = [source]

    while Q:
        current_node = Q.popleft()
        for neighbor in graph[current_node]:
            if neighbor not in visited:
                visited.add(neighbor)
                dist[neighbor] = dist[current_node] + 1
                paths[neighbor] = paths[current_node] + [neighbor]
                Q.append(neighbor)

    for v in range(n+1):
        if v not in visited:
            paths[v] = None

    result = [(dist[i], paths.get(i)) for i in range(len(dist))]

    return result

"""### **Sample Tests**

"""

n = 4
edges = [[0,1], [1,2], [2,3], [3,4]]
shortest_paths_from_source(n, edges, source=4)

n = 5
edges = [[0,2], [2,4], [0,4], [1,3], [3,5], [1,5]]
shortest_paths_from_source(n, edges, 1)

"""#### **Sample Test with big data.**
The input is read from the file and the result is written on the output file.

This sample represents a graph with 37700 nodes, and 289003 edges
"""

def read_input_file(file_name):
    biggest_vertex_number = 0
    edges = []
    with open(file_name, 'r') as file:
        for line in file:
            u, v = map(int, line.split())
            edges.append([u,v])
            biggest_vertex_number = max(biggest_vertex_number, u, v)
    return biggest_vertex_number, edges

def write_output_file(paths_result, output_file_name):
  with open(output_file_name, 'w') as file:
    for path in paths_result:
      file.write(str(path) + "\n")

n, edges = read_input_file("input_sample_Huge.txt")
paths = shortest_paths_from_source(n, edges, 1)
write_output_file(paths, "output_sample_Huge.txt")