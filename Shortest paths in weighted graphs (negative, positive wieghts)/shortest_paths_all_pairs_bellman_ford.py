# -*- coding: utf-8 -*-
"""shortest_paths_all_pairs_Bellman-Ford.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WmMYdewptQphLbDn6HHds3oTL-F05KNe

# **Author: Shekoofhe Nekooei Rizi**


In this program, I implement the **Bellman-Ford algorithm** to find the shortest paths between all pairs of vertices in a directed and weighted graph.

The weights might be positive or negative.


The vertices of the input graph are consecutive integers from 1 to n.

The edges are represented as a list of tuples in the form of (head, tail, weight), where weight is the cost of the directed edge from tail to head.


I provide small examples, followed by samples using larger datasets to evaluate the program's performance. In my experience, it took around 6 minitues to compute shortest paths in "sample_3.txt" input.
"""

import numpy as np

def all_pairs_bellman_ford(n, edges):
    """ This function computes shortest paths between all pairs using [nested] Bellman-Ford algorithm.

    Input:
    n: The number of nodes in the graph. Note that vertices are consecutive integers from 1 to n (inclusive).

    edges: A list of tuples in the form of (head, tail, weight), where weight is the cost of the directed edge from tail to head.

    Output:
    dist_matrix: np.ndarray(shape=(n, n))
    It stornes the shortest path distances between all pairs of nodes.
    dist_matrix[i][j] is the shortest path distance (lowest cost path) from node i+1 to j+1.
    If there is no path, or the path affected by a negative cycle the value for the corresponding shortest distance is inf or -inf, respectivly.

    path_matrix: list of lists of edges in the form of (head, tail, weight).
    path_matrix[i][j] is the shortest path from node i+1 to j+1.
    If there is no path, or the path affected by a negative cycle the value for the corresponding shortest path is None.
    """

    infinity = float('inf')
    dist_matrix = np.full((n, n), infinity)
    path_matrix = [[None] * n for _ in range(n)]

    def bellman_ford_source_to_all(source):
        """ Computes shortest paths from a single source using Bellman-Ford """
        nonlocal dist_matrix, path_matrix, n, edges

        dist = np.full(n, infinity)
        dist[source] = 0
        path = [[] for _ in range(n)]
        #path = [None for _ in range(n)]

        # Relax edges up to (n-1) times
        for _ in range(n - 1):
            updated = False
            for u, v, w in edges:
                if dist[u - 1] < infinity and dist[v - 1] > dist[u - 1] + w:
                    dist[v - 1] = dist[u - 1] + w
                    path[v - 1] = path[u - 1] + [(u, v, w)]
                    updated = True
            if not updated:
                break

        for u, v, w in edges:
            if dist[u - 1] < infinity and dist[v - 1] > dist[u - 1] + w:
                dist[v - 1] = -infinity
                path[v - 1] = None

        dist_matrix[source] = dist
        path_matrix[source] = [p if p else None for p in path]

    for src in range(n):
        bellman_ford_source_to_all(src)

    return dist_matrix, path_matrix

"""## **Sample Tests**"""

n = 4
edges = [(1, 2, -10), (2, 3, 20), (3, 4, -30)]
all_pairs_bellman_ford(n, edges)

n = 4
edges = [(1, 2, -10), (2, 1, -10), (3, 4, 20), (4, 3, 200)]
all_pairs_bellman_ford(n, edges)

n = 3
edges = [(1, 2, 10), (2, 1, 10), (1, 3, 10), (3, 1, 10), (2, 3, 10), (3, 2, 10)]
all_pairs_bellman_ford(n, edges)

"""### **Samples with Big Data**"""

def read_input(filename):
    with open(filename, 'r') as file:
        first_line = file.readline().strip()
        n, m = map(int, first_line.split())
        edges = []
        for _ in range(m):
            line = file.readline().strip()
            u, v, w = map(int, line.split())
            edges.append([u, v, w])
    return n, edges

n3, edges3 = read_input('sample_3.txt')

distances, paths = all_pairs_bellman_ford(n3, edges3)

"""If we were to write the output of the above line to a file, it would be an enormous file, making it time-consuming to download or open.

Instead, I run some experiments with the results in a more manageable way:

I identify the shortest shortest path by finding all paths with the minimum distance.

I also determine the longest shortest paths.
"""

shortest_shortest_distance = distances.min()
min_locations = np.where(distances == shortest_shortest_distance)
print(min_locations)

print("The distance of the shortest shortest path is: ", distances[398, 903])
print("\nThe path is as follows:")
paths[398][903]

longsest_shortest_distance = distances.max()
max_locations = np.where(distances == longsest_shortest_distance)
print(max_locations)

print("The distance of the longest shortest path is: ", distances[831, 1])
print("\nThe path is as follows:")
paths[831][1]

print("The distance of the longest shortest path is: ", distances[831, 195])
print("\nThe path is as follows:")
paths[831][195]

print("The distance of the longest shortest path is: ", distances[831, 197])
print("\nThe path is as follows:")
paths[831][197]

print("The distance of the longest shortest path is: ", distances[831, 398])
print("\nThe path is as follows:")
paths[831][398]

print("The distance of the longest shortest path is: ", distances[831, 460])
print("\nThe path is as follows:")
paths[831][460]

print("The distance of the longest shortest path is: ", distances[831, 527])
print("\nThe path is as follows:")
paths[831][527]

