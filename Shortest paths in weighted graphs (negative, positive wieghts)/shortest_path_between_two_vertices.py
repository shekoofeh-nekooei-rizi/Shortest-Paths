# -*- coding: utf-8 -*-
"""shortest_path_between_two_vertices.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sgjDr9uxoAP23aBJ6uz4NWmTDYbq2jDU

# **Author: Shekoofhe Nekooei Rizi**


In this program, I implement the **Bellman_Ford algorithm** to find the shortest path between two given vertices in a directed and weighted graph.

The weights might be positive or negative.


The vertices of the input graph are consecutive integers from 1 to n.

The edges are represented as a list of tuples in the form of (head, tail, weight), where weight is the cost of the directed edge from tail to head.


I provide small examples, followed by test samples using larger datasets to evaluate the program's performance.
"""

from collections import deque

def bellman_ford_two_vertices(n, edges, start, terminal):
    """
    This function computes the shortest path starting from vertex 'start' to vertex 'terminal'.
    'n' is the number of vertices in the graph. Note that vertices are denoted by integer numbers in range 1 to n (inclusive)
    'edges' is a list of tuples in the form of (u, v, w), where 'w' is the cost of the directed edge from 'u' to 'v'.
    'start' and 'terminal' are the source and terminal vertices. They are both integer numbers in range 1 to n (inclusive).

    Returns:
    (distance, shortest_path)
    'distance' is the sum of edge weights in 'shortest_path'.
    'shortest_path' is the sequence of edges in the shortest path from 'start' to 'terminal'


    When no path exists, it returns (inf, None).
    When a negative cycle affects the path between 'start' and 'terminal', it returns (-inf, None).
    """

    if start == terminal:
        return 0, None

    graph = {v:[] for v in range(1, (n+1))}
    for e in edges:
        graph[e[0]].append((e[1], e[2]))

    infinity = float('inf')
    dist = [infinity] * (n+1)
    dist[start] = 0

    parent_edge = [None] * (n+1)

    def path_reconstruction(target):
        nonlocal parent_edge, start
        path = []
        trace = parent_edge[target]
        while trace is not None:
            path.append(trace)
            if  trace[0] == start:
                break
            trace = parent_edge[trace[0]]
        path.reverse()
        return path

    for _ in range(n-1):
        for u, v, w in edges:
            if dist[v] > dist[u] + w:
                dist[v] = dist[u] + w
                parent_edge[v] = (u, v, w)


    if dist[terminal] == infinity:
        return dist[terminal], None

    no_shortest_path_exists = set()

    input_does_not_have_negative_cycle = True
    for u, v, w in edges:
        if dist[v] > dist[u] + w:
            input_does_not_have_negative_cycle = False
            no_shortest_path_exists.add(v)

    if input_does_not_have_negative_cycle:
        return dist[terminal], path_reconstruction(terminal)

    Q = deque()
    visited = set()
    for node in no_shortest_path_exists:
        Q.append(node)
        visited.add(node)
        while Q:
            current_v = Q.popleft()
            dist[current_v] = -infinity
            if current_v == terminal:
                return dist[terminal], None # Path exists but Shortest path does not
            for neighbor in graph[current_v]:
                if neighbor[0] not in visited:
                    Q.append(neighbor[0])
                    visited.add(neighbor[0])

    return dist[terminal], path_reconstruction(terminal)

"""## **Small Samples**"""

n = 3
edges = [(1, 2, -10), (2, 3, -10)]
bellman_ford_two_vertices(n, edges, 1, 3)

n = 4
edges = [(1, 2, -100), (2, 1, 50), (3, 4, 10)]
bellman_ford_two_vertices(n, edges, 1, 4)

n = 6
edges = [(1, 2, -100), (2, 1, 50), (3, 4, 10), (4, 3, 10), (4, 5, 10), (4, 6, 20), (5, 6, 100)]
bellman_ford_two_vertices(n, edges, 2, 1)

n = 6
edges = [(1, 2, 10), (2, 3, 5), (1, 3, 100), (3, 5, 7), (5, 4, 10), (4, 3, -18), (6, 1, -1)]

bellman_ford_two_vertices(n, edges, 3, 5)

"""### **Samples with big data**
Here we read data from sample files.
Each sample in "sample_1.txt", "sample_2.txt" and "sample_3.txt" is a directed graph, weighted graph.
The first line in each file is n: number/range of vertices and m: the number of edges.
The following m lines are directed weightted edges.
"""

def read_input(filename):
    with open(filename, 'r') as file:
        first_line = file.readline().strip()
        n, m = map(int, first_line.split())
        edges = []
        for _ in range(m):
            line = file.readline().strip()
            u, v, w = map(int, line.split())
            edges.append([u, v, w])
    return n, edges

n1, edges1 = read_input('sample_1.txt')

bellman_ford_two_vertices(n1, edges1, 1, 2)

n2, edges2 = read_input('sample_2.txt')

bellman_ford_two_vertices(n2, edges2, 4, 999)

n3, edges3 = read_input('sample_3.txt')

bellman_ford_two_vertices(n3, edges3, 4, 5)

bellman_ford_two_vertices(n3, edges3, 10, 1)

bellman_ford_two_vertices(n3, edges3, 1000, 999)

import random

source = random.randint(1, n3)
terminal = random.randint(1, n3)
print("Shortest path from   " + str(source) + "   to   " + str(terminal))
bellman_ford_two_vertices(n3, edges3, source, terminal)