# -*- coding: utf-8 -*-
"""shortest_paths_between_a_source_and_all_vertices.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qkLr7NZBiSA5LDl-7Om0bGSIUpMidhVy

# **Author: Shekoofhe Nekooei Rizi**


In this program, I implement the **Bellman-Ford algorithm** to find the shortest paths between a given vertex as 'source' to all vertices in a directed and weighted graph.

The edges weights might be positive or negative (or zero).


The vertices of the input graph are consecutive integers from 1 to n.

The edges are represented as a list of tuples in the form of (head, tail, weight), where weight is the cost of the directed edge from tail to head.


I provide small examples, followed by samples using larger datasets to evaluate the program's performance.
"""

from collections import deque

def bellman_ford_source_to_all(n, edges, source):
    """
    This function computes the shortest paths from a given source vertex to all vertices in a directed and weighted graph using the Bellman-Ford algorithm. Weights can be positive or negative values or possibly 0. The vertices of the graph are consecutive integers from 1 to n.

    Input:
    n: The number of nodes in the graph. Note that vertices are consecutive integers from 1 to n (inclusive).

    edges: A list of tuples in the form of (head, tail, weight), where weight is the cost of the directed edge from tail to head.

    source: An integer number identifying the source vertex.

    Output:
    The function returns a list of tuples, where each tuple is in the following form:
    (source -> terminal, shortest_path_cost, [shortest_path])

    source -> terminal: a string representing the path from the "source" vertex to "teminal"

    shortest_path_cost: the total cost of the shortest path from the source to the terminal node.

    [shortest_path]: a list of consecutive edges that make up the shortest path, or None if no path or no shortest path exists.

    """

    graph = {v:[] for v in range(1, n+1)}
    for edge in edges:
        graph[edge[0]].append((edge[1], edge[2]))

    infinity = float('inf')
    dist = [infinity] * (n+1)
    dist[source] = 0

    paths = {v:[] for v in range(1, n+1)}
    paths[source] = []

    for _ in range(n-1):
        for u, v, w in edges:
            if dist[v] > dist[u] + w:
                dist[v] = dist[u] + w
                paths[v] = paths[u] + [(u, v, w)]

    no_shortest_path_exists = set()

    for u, v, w in edges:
        if dist[v] > dist[u] + w:
            no_shortest_path_exists.add(v)

    Q = deque(no_shortest_path_exists)
    while Q:
        current_v = Q.popleft()
        dist[current_v] = -infinity
        for neighbor, _ in graph[current_v]:
            if neighbor not in no_shortest_path_exists:
                no_shortest_path_exists.add(neighbor)
                Q.append(neighbor)

    for v in range(1, n+1):
        if (dist[v] == infinity) or (v in no_shortest_path_exists):
            paths[v] = None

    paths[source] = None
    result = [(str(source) + "->" + str(i), d, paths[i]) for i, d in enumerate(dist[1:], 1) if i in paths]

    return result

"""## **Samples Tests**"""

n = 5
edges = [(1, 2, 10), (4, 1, 20), (2, 3, 20), (3, 1, 5)]
bellman_ford_source_to_all(n, edges, 4)

n = 4
edges = [(1, 2, 10), (4, 1, 20), (2, 3, 20), (3, 1, -50)]
bellman_ford_source_to_all(n, edges, 4)

bellman_ford_source_to_all(n, edges, 1)

n = 9
edges = [(8, 9, 10), (2, 9, 1), (1, 2, 10), (2, 3, 5), (1, 3, 100), (3, 5, 7), (7, 8, 100), (5, 4, 10), (4, 3, -18), (6, 1, -1), (2, 7, 200)]

bellman_ford_source_to_all(n, edges, 1)

"""### **Samples with Big Data**

The first line in the input file indicates the number of vertices and edges, respectively.

Each subsequent line describes a directed weighted edge:

the first two numbers are its tail and head, respectively, and the third number its length (cost).
"""

def read_input(filename):
    with open(filename, 'r') as file:
        first_line = file.readline().strip()
        n, m = map(int, first_line.split())
        edges = []
        for _ in range(m):
            line = file.readline().strip()
            u, v, w = map(int, line.split())
            edges.append([u, v, w])
    return n, edges

def write_output_file(result, output_file_name):
    with open(output_file_name, 'w') as file:
        for row in result:
            file.write(str(row) + "\n\n")

n3, edges3 = read_input('sample_3.txt')

shortest_paths = bellman_ford_source_to_all(n3, edges3, 1000)

write_output_file(shortest_paths, 'output_sample_3_source_to_all.txt')

shortest_paths = bellman_ford_source_to_all(n3, edges3, 832)
write_output_file(shortest_paths, 'output_ss.txt')

"""For this example test, I use  the data from "sample_1.txt" as input.

Through the "negative_cycle_detection.py" program, we know there exists a negative cycle in the corresponding graph for this data.

"strongly_connected_components_iterative_version.py" program in my other repository, shows that there is only one strongly connected component in the coreesponding graph.

Therefore, all pairs of vertices are affected by the negative cycle, and the shortest paths between any source and all other nodes would cost negative infinity.

Here I randoumly select a source vertex.

Please note that, despite the equal input sizes of "sample_1.txt" and "sample_3.txt" (both with 1000 nodes and ~48000 edges) the running time here for sample_1.txt is [much] longer due to the negative cycle affecting all paths. Yet, both programs complete in seconds.
"""

from random import randint

source = randint(1, 1000)
print("Source vertex, randomly picked, is: ", source)

n1, edges1 = read_input('sample_1.txt')

shortest_paths = bellman_ford_source_to_all(n1, edges1, source)

write_output_file(shortest_paths, 'output_sample_1_source_to_all.txt')