# -*- coding: utf-8 -*-
"""Negative_cycle_detection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Tsw3cPru3AIBcmDmKIIRtp5zjWsl_WON

### **Author: Shekoofeh Nekooei Rizi**
In this Python program, I implemtn the **Bellman-Ford algorithm** to determine whether a given directed, weighted graph contains any negative cycles (a cycle where the sum of edge weights is negative).

Vertices of the input graph are consecutive integer numbers from 1 to n (inclusive).  

Each edge has a weight, which can be a negative or a positive number or zero.

The program returns one negative cycle if there exists any; otherwise, it returns `False`.

I include some small toy examples and then run the program on three big sample inputs.

For these big samples we read problems's data from the correstponding files.

"sample_1.txt", "sample_2.txt", and "sample_3.txt" are data for three graphs, each of which represents a different graph with 1000 vertices and around 48000 edges.
"""

def has_negative_cycle(n, edges):
    """
    This function determines whether a given directed, weighted graph contains any negative-weight cycles. If the input contains a negative cycle, it finds one such cycle along with its total weight; otherwise, it returns False.

    Function input parameters:
    n: the number of vertices in the graph. Note the vertices are from 1 to n.
    edges: a list of tuples in the form of (u, v, w) where u is the head vertex, v is the tail vertex, and w is the weight cost of that edge.

    output:
    a tuple in the form of (total_cycle_weight, [cycle edges]) if the input contains a negative cycle; otherwise, it returns False
    [cycle edges] is a list of tuples in the form of (u, v, w) as consecutive edges forming the negative cycle. total_cycle_weight is the sum of the third elements of these edges.
    """
    for node in range(n):
        edges.append((0, node, 0))
    infinity = float('inf')
    dist = [infinity] * (n+1)
    dist[0] = 0
    parent_edge = [None] * (n+1)
    for _ in range(n-1):
        for u, v, w in edges:
            if dist[v] > dist[u] + w:
                dist[v] = dist[u] + w
                parent_edge[v] = (u, v, w)

    status = False
    for u, v, w in edges:
        if dist[v] > dist[u] + w:
            status = True
            edge_infected_by_negative_cyle = (u, v, w)
            break

    if not status:
        return False

    negative_cycle = []
    trace = edge_infected_by_negative_cyle
    for _ in range(n):
        trace = parent_edge[trace[0]]

    last_edge_in_round = trace
    while True:
        negative_cycle.append(trace)
        trace = parent_edge[trace[0]]
        if trace == last_edge_in_round:
            break

    negative_cycle.reverse()
    weight = sum([edge[2] for edge in negative_cycle])
    return weight, negative_cycle

"""## **Sample Tests**"""

has_negative_cycle(5, [(4, 3, 10)])

n = 4
edges = [(2, 1,-100), (1, 2, 50), (3, 4, -400), (4, 3, 200)]
has_negative_cycle(n, edges)

n = 3
edges = [(1, 2, 1), (2, 3, 1), (3, 1, 1)]
has_negative_cycle(n, edges)

n = 7
edges = [(1, 2, -1), (2,3, 4), (4,5,-1), (5,6, 2), (6,4, -3), (6, 7, -2), (7, 6, -2), (3, 1,-9)]
has_negative_cycle(n, edges)

"""### **Sample Tests with big data**

Here, we read data from sample files.

Each file—"sample_1.txt", "sample_2.txt", and "sample_3.txt"—contains a directed, weighted graph.

The first line in each file specifies **n**, the number of vertices, and **m**, the number of edges.

The following m lines list the edges in the format (u, v, w), where w is the weight of the directed edge from u to v
"""

def read_input(filename):
    with open(filename, 'r') as file:
        first_line = file.readline().strip()
        n, m = map(int, first_line.split())
        edges = []
        for _ in range(m):
            line = file.readline().strip()
            u, v, w = map(int, line.split())
            edges.append([u, v, w])
    return n, edges

n1, edges1 = read_input('sample_1.txt')

has_negative_cycle(n1, edges1)

n2, edges2 = read_input('sample_2.txt')

has_negative_cycle(n2, edges2)

n3, edges3 = read_input('sample_3.txt')
has_negative_cycle(n3, edges3)

